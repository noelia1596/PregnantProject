{"ast":null,"code":"/**\r\n * Map series module\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Series, SeriesDataItem } from \"../series/Series\";\nimport { registry } from \"../../core/Registry\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $type from \"../../core/utils/Type\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[MapSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar MapSeriesDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(MapSeriesDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function MapSeriesDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"MapSeriesDataItem\";\n    _this.values.value = {};\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(MapSeriesDataItem.prototype, \"value\", {\n    /**\r\n     * @return Value\r\n     */\n    get: function get() {\n      return this.values.value.value;\n    },\n\n    /**\r\n     * Numeric value of the data item.\r\n     *\r\n     * Value may be used in heat-map calculations.\r\n     *\r\n     * @param value  Value\r\n     */\n    set: function set(value) {\n      this.setValue(\"value\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates the item's bounding coordinates: coordinates of the East, West,\r\n   * North, and South-most points.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param geoPoints  Points of the element\r\n   */\n\n  MapSeriesDataItem.prototype.updateExtremes = function (geoPoints) {\n    for (var s = 0; s < geoPoints.length; s++) {\n      var longitude = geoPoints[s].longitude;\n      var latitude = geoPoints[s].latitude;\n\n      if (this.west > longitude || !$type.isNumber(this.west)) {\n        this.west = longitude;\n      }\n\n      if (this.east < longitude || !$type.isNumber(this.east)) {\n        this.east = longitude;\n      }\n\n      if (this.north < latitude || !$type.isNumber(this.north)) {\n        this.north = latitude;\n      }\n\n      if (this.south > latitude || !$type.isNumber(this.south)) {\n        this.south = latitude;\n      }\n    }\n  };\n\n  Object.defineProperty(MapSeriesDataItem.prototype, \"zoomLevel\", {\n    /**\r\n     * @return Zoom level\r\n     */\n    get: function get() {\n      return this.properties[\"zoomLevel\"];\n    },\n\n    /**\r\n     * When `zoomToMapObject()` is called the map will either calculate suitable\r\n     * zoom level itself or use object's `zoomLevel` if set.\r\n     *\r\n     * @param value  Zoom level\r\n     */\n    set: function set(value) {\n      this.setProperty(\"zoomLevel\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeriesDataItem.prototype, \"zoomGeoPoint\", {\n    /**\r\n     * @return Zoom geo point\r\n     */\n    get: function get() {\n      return this.properties[\"zoomGeoPoint\"];\n    },\n\n    /**\r\n     * When `zoomToMapObject()` is called the map will either calculate suitable\r\n     * center position itself or use object's `zoomGeoPoint` if set.\r\n     *\r\n     * @param value  Zoom geo point\r\n     */\n    set: function set(value) {\n      this.setProperty(\"zoomGeoPoint\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return MapSeriesDataItem;\n}(SeriesDataItem);\n\nexport { MapSeriesDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * A base class for series of map objects.\r\n *\r\n * @see {@link IMapSeriesEvents} for a list of available Events\r\n * @see {@link IMapSeriesAdapters} for a list of available Adapters\r\n * @important\r\n */\n\nvar MapSeries =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(MapSeries, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function MapSeries() {\n    var _this = // Init\n    _super.call(this) || this;\n\n    _this.className = \"MapSeries\"; // Set defaults\n\n    _this.isMeasured = false;\n    _this.nonScalingStroke = true; // Set data fields\n\n    _this.dataFields.value = \"value\"; // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n\n\n  MapSeries.prototype.createDataItem = function () {\n    return new MapSeriesDataItem();\n  };\n  /**\r\n   * (Re)validates series data, effectively causing the whole series to be\r\n   * redrawn.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  MapSeries.prototype.validateData = function () {\n    var _this = this;\n\n    _super.prototype.validateData.call(this);\n\n    $iter.each(this.dataItems.iterator(), function (dataItem) {\n      if (_this.west > dataItem.west || !$type.isNumber(_this.west)) {\n        _this.west = dataItem.west;\n      }\n\n      if (_this.east < dataItem.east || !$type.isNumber(_this.east)) {\n        _this.east = dataItem.east;\n      }\n\n      if (_this.north < dataItem.north || !$type.isNumber(_this.north)) {\n        _this.north = dataItem.north;\n      }\n\n      if (_this.south > dataItem.south || !$type.isNumber(_this.south)) {\n        _this.south = dataItem.south;\n      }\n    });\n\n    if (this.chart) {\n      this.chart.updateExtremes();\n    }\n  };\n  /**\r\n   * Checks whether object should be included in series.\r\n   *\r\n   * @param includes  A list of explicitly included ids\r\n   * @param excludes  A list of explicitly excluded ids\r\n   * @param id        Id of the object\r\n   * @return Include?\r\n   */\n\n\n  MapSeries.prototype.checkInclude = function (includes, excludes, id) {\n    if (includes) {\n      if (includes.length == 0) {\n        return false;\n      } else {\n        if (includes.indexOf(id) == -1) {\n          return false;\n        }\n      }\n    }\n\n    if (excludes && excludes.length > 0) {\n      if (excludes.indexOf(id) != -1) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Object.defineProperty(MapSeries.prototype, \"useGeodata\", {\n    /**\r\n     * @return Use GeoJSON data?\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"useGeodata\");\n    },\n\n    /**\r\n     * Should the map extract all the data about element from the GeoJSON?\r\n     *\r\n     * This is especially relevant for [[MapPolygonSeries]]. If not set to `true`\r\n     * polygon series will need to contain geographical data in itself in order\r\n     * to be drawn.\r\n     *\r\n     * If this is set to `true`, series will try to extract data for its objects\r\n     * from either chart-level `geodata` or from series' `geodata` which holds\r\n     * map infor in GeoJSON format.\r\n     *\r\n     * @default false\r\n     * @param value  Use GeoJSON data?\r\n     */\n    set: function set(value) {\n      if (this.setPropertyValue(\"useGeodata\", value)) {\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"include\", {\n    /**\r\n     * @return Included objects\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"include\");\n    },\n\n    /**\r\n     * A list of object ids that should be explictly included in the series.\r\n     *\r\n     * If this is not set, the series will automatically include all of the\r\n     * objects, available in the GeoJSON map. (minus the ones listed in\r\n     * `exclude`)\r\n     *\r\n     * If you need to display only specific objects, use `include`. E.g.:\r\n     *\r\n     * `include = [\"FR\", \"ES\", \"DE\"];`\r\n     *\r\n     * The above will show only France, Spain, and Germany out of the whole map.\r\n     *\r\n     * @param value  Included objects\r\n     */\n    set: function set(value) {\n      if (this.setPropertyValue(\"include\", value)) {\n        this.processIncExc();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  MapSeries.prototype.processIncExc = function () {\n    //this.data = [];\n    this.invalidateData();\n  };\n\n  Object.defineProperty(MapSeries.prototype, \"exclude\", {\n    /**\r\n     * @return Excluded ids\r\n     */\n    get: function get() {\n      return this.getPropertyValue(\"exclude\");\n    },\n\n    /**\r\n     * A list of object ids that should be excluded from the series.\r\n     *\r\n     * E.g. you want to include all of the areas from a GeoJSON map, except\r\n     * Antarctica.\r\n     *\r\n     * You'd leave `include` empty, and set `exclude = [\"AQ\"]`.\r\n     *\r\n     * @param value  Excluded ids\r\n     */\n    set: function set(value) {\n      if (this.setPropertyValue(\"exclude\", value)) {\n        this.processIncExc();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Decorates a newly added object.\r\n   *\r\n   * @param event [description]\r\n   */\n\n  MapSeries.prototype.handleObjectAdded = function (event) {\n    var mapObject = event.newValue;\n    mapObject.parent = this;\n    mapObject.series = this;\n    mapObject.strokeWidth = mapObject.strokeWidth;\n  };\n\n  Object.defineProperty(MapSeries.prototype, \"geodata\", {\n    /**\r\n     * @return GeoJSON data\r\n     */\n    get: function get() {\n      return this._geodata;\n    },\n\n    /**\r\n     * Map data in GeoJSON format.\r\n     *\r\n     * The series supports the following GeoJSON objects: `Point`, `LineString`,\r\n     * `Polygon`, `MultiPoint`, `MultiLineString`, and `MultiPolygon`.\r\n     *\r\n     * @see {@link http://geojson.org/} Official GeoJSON format specification\r\n     * @param geoJSON GeoJSON data\r\n     */\n    set: function set(geodata) {\n      if (geodata != this._geodata) {\n        this._geodata = geodata;\n        this.invalidateData();\n        $iter.each(this._dataUsers.iterator(), function (x) {\n          x.invalidateData();\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"geodataSource\", {\n    /**\r\n     * Returns a [[DataSource]] specifically for loading Component's data.\r\n     *\r\n     * @return Data source\r\n     */\n    get: function get() {\n      if (!this._dataSources[\"geodata\"]) {\n        this.getDataSource(\"geodata\");\n      }\n\n      return this._dataSources[\"geodata\"];\n    },\n\n    /**\r\n     * Sets a [[DataSource]] to be used for loading Component's data.\r\n     *\r\n     * @param value Data source\r\n     */\n    set: function set(value) {\n      var _this = this;\n\n      if (this._dataSources[\"geodata\"]) {\n        this.removeDispose(this._dataSources[\"geodata\"]);\n      }\n\n      this._dataSources[\"geodata\"] = value;\n      this._dataSources[\"geodata\"].component = this;\n      this.events.on(\"inited\", function () {\n        _this.loadData(\"geodata\");\n      }, undefined, false);\n      this.setDataSourceEvents(value, \"geodata\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n  * Processes JSON-based config before it is applied to the object.\r\n  *\r\n  * @ignore Exclude from docs\r\n  * @param config  Config\r\n  */\n\n  MapSeries.prototype.processConfig = function (config) {\n    if ($type.hasValue(config[\"geodata\"]) && $type.isString(config[\"geodata\"])) {\n      var name_1 = config[\"geodata\"]; // Check if there's a map loaded by such name\n\n      if ($type.hasValue(window[\"am4geodata_\" + config[\"geodata\"]])) {\n        config[\"geodata\"] = window[\"am4geodata_\" + config[\"geodata\"]];\n      } // Nope. Let's try maybe we got JSON as string?\n      else {\n          try {\n            config[\"geodata\"] = JSON.parse(config[\"geodata\"]);\n          } catch (e) {\n            // No go again. Error out.\n            throw Error(\"MapChart error: Geodata `\" + name_1 + \"` is not loaded or is incorrect.\");\n          }\n        }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return MapSeries;\n}(Series);\n\nexport { MapSeries };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"MapSeries\"] = MapSeries;\nregistry.registeredClasses[\"MapSeriesDataItem\"] = MapSeriesDataItem;","map":null,"metadata":{},"sourceType":"module"}